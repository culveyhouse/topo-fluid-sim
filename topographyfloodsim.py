#!/usr/bin/env Python

import sys
import argparse
import time
import random
from itertools import count

# Default dimensions if no grid length / width / height specified
DEFAULT_LENGTH, DEFAULT_WIDTH, DEFAULT_MAX_HEIGHT = 8, 8, 10 
# Descriptive key for 3D cube contents
CONTENT_AIR, CONTENT_BOARD, CONTENT_WATER = 0, 1, 2

'''
The argument parser is used if the user wishes to generate random grids
without passing a user-defined grid through the program.
The user may specify any of the following: length, width, and/or maximum 
height of the "topography" to be generated.
'''
parser = argparse.ArgumentParser(description='Pass arguments for random grid \
                    generation')
parser.add_argument('-l','--length', dest='grid_length', metavar='grid length',
                    type=int, default=None, help='length of random \
                    topography grid')
parser.add_argument('-w','--width', dest='grid_width', metavar='grid width', 
                    type=int, default=None, help='width of random topography \
                    grid')
parser.add_argument('--mh','--max-height', dest='max_height', 
                    metavar='maximum height', type=int, default=None, 
                    help='maximum height of random topography grid')
args = parser.parse_args() 
 
 
class MakeCartesianGrid:
    """
    MakeCartesianGrid accepts input of heights for a 2D grid of
    squares, then produces a 3D array (cartesian grid) representing that 
    topography. The 2D grid should be generated by prepare_grid(). 
    
    The 3D array's height is simply the height of the square with the highest
    elevation. You must know the height (maximum value) of the 2D grid in order
    to call this function, which can be easily computed with prepare_grid().
    The 3D array will store contents as follows: 0: air, 1: board,
    and 2: water.

    ...
    Parameters
    ----------
    grid : 2D arr/list of lists
        the 2D grid represented as a 2D Python array 
    height : int
        the height of the 3D grid
    manual_run : bool, optional, default False
        flag to indicate whether to automatically run the extrusion 
    
    Attributes
    ----------
    grid : the 2D grid represented as a 2D Python array 
    length : int
        the length from the 2D grid input
    width : int
        the width from the 2D grid input
    cubes : 3d arr / list of lists of lists of TopoCube objects
        a 3D cube matrix of TopoCube instances used to track contents of the 3D 
        space

    Methods
    -------
    extrude()
        Produces a 3D array of TopoCubes by extruding the heights of each 
        grid square.
    """      
    
    def __init__(self, grid, height, manual_run=False):
        self.length = len(grid[0])
        self.width = len(grid)
        self.height = height
        self.grid = grid # 
        self.cubes = \
            [[[CONTENT_AIR for z in range(self.height)] \
            for y in range(self.width)] \
            for x in range(self.length)] 
        if not manual_run:
            self.extrude()
        
    def extrude(self, grid=None):
        """
        extrude() creates a 3D array representing a 3D Cartesian grid of cubes, 
        starting with the 2D topo_grid array and extruding each square into a 
        z-axis per the value (height) of each array element. The
        topographical 'cubes' will have a value of 1 (board material), and all
        other cubes will have a value of 0 (air material)
        
        Parameters
        ----------
        grid : 2D arr/list of lists, optional
            A Python 2D array (list of lists) which can be passed to override
            the grid_array already defined within the class init.
    
        Returns
        -------
        cube_grid : 3D arr / list of list of lists of TopoCube objects
            A fullly extruded 3d Python array, with int values of either 0 (air)
            or 1 (board)
        """
        
        if grid is None:
            grid = self.grid

        # Build the 3D grid in order of y, x, and then z axes
        for y in range(self.width):
            for x in range(self.length):
                for z in range(self.height):
                    self.cubes[x][y][z] = TopoCube(coords=(x,y,z))
                
                    # Build board cubes upwards to height value of x,y
                    if grid[y][x]-1>=z:
                        self.cubes[x][y][z].content = CONTENT_BOARD
                        
        return self.cubes

class TopoCube:
    """
    TopoCube allows for a collection of Cube objects that compose a 3D
    cartesian grid. TopoCube objects are created in the MakeCartesianGrid
    class, and are created en masse on 3D grid initialization. For example,
    an 8x8x8 grid will instantiate 512 objects. 
    
    For this reason, this is a "lite" class using the __slots__ method
    which keeps each cube object lightweight and speeds up data retrieval.
    
    ...
    Attributes
    ----------
    coords : list
        (x, y, z) coordinates of the cube 
    content : int, default 0
        The material currently occupying the cube via 3 global variables:
        0: air, 1: board, 2: water
    drains_out : bool, default False
        flag to indicate if this cube drains to any lower height 
    """
    
    __slots__ = ('coords', 'content', 'drains_out')
    
    def __init__(self, coords: list, content = 0, drains_out = False):
        self.coords = coords
        self.content = int(content)
        self.drains_out = drains_out

def prepare_grid(topo_grid=None, length=None, width=None, max_height = None):
    """
    prepare_grid accepts a standard Python 2d array input, and normalizes it 
    for extrusion by the MakeCartesianGrid class. It assumes an "x" length 
    based on the length of the first array, then truncates or fills the rest
    of the "y" arrays. It also computes the maximum elevation of the grid's
    values.
    
    Alternatively, instead of passing a 2D array as topo_grid, you may create a 
    random 2D grid of height values by supplying length, width, and maximum
    height desired. 

    Parameters
    ----------
    topo_grid : 2D arr/list of lists, optional
        A 2d Python array, square or rectangular
    length : int, optional, defaults to DEFAULT_LENGTH
        Desired length of a randomized 2D grid
    width : int, optional, defaults to DEFAULT_WIDTH
        Desired width of a randomized 2D grid, 
    max_height : int, optional, defaults to DEFAULT_MAX_HEIGHT
       Maximum values (height) of a randomized 2D grid

    Returns
    -------
    (topo_grid, board_max_height) : tuple (2D arr/list of lists, int)
        1. The final 2D array, or in other words a groomed grid 
        for use with MakeCartesianGrid, and
        2. The maximum value detected in the 2D grid, also called
        maximum height.
    """
    
    if topo_grid is None: 
        # randomizing a 2D grid
        board_length = length or DEFAULT_LENGTH
        board_width = width or DEFAULT_WIDTH
        board_max_height = max_height or DEFAULT_MAX_HEIGHT
        print(f"Randomizing a topography grid of {board_length}x{board_width}" +
            f" with values 0-{board_max_height}")

        #Randomize values in 2D array up to maximum height calculated above
        topo_grid = [[random.randint(0,board_max_height) 
            for i in range(board_length)] for j in range(board_width)]
        print("Your random topography grid is:")
    else: 
        # base board length on the first row's length
        board_length = len(topo_grid[0])
        board_width = len(topo_grid)
        board_max_height = max(map(max, topo_grid))
        
        # Fill incomplete rows with zeros for uniform row length
        for y in range(board_width):
            row = topo_grid[y]
            if len(row) < board_length:
                row.extend([0 for i in range((board_length-len(row)))])  
            # trim longer rows to first row's length
            topo_grid[y] = row[0:board_length]
        print("Your custom topography grid is:")  
        
    print_grid(topo_grid)
    return topo_grid, board_max_height
    
def print_grid(topo_grid):
    """
    Prints a right-aligned table of integers representing the heights
    of each square in the 2D array passed. This grid printer allows
    for integers of up to 2 digits. The 2D array must be square or
    rectangular, as there is currently no error handling for 
    extraneous array elements. 
    
    To minimize possible errors, always pass a 2D grid of 'height' values 
    through prepare_grid() first to properly groom the topography grid.

    Parameters
    ----------
    topo_grid : 2D arr/list of lists
        A 2d Python array of integers, square or rectangular
    """    
    for i in range(len(topo_grid)):
        print("|", end="")
        for j in range(len(topo_grid[0])):
            print(str(topo_grid[i][j]).rjust(2), end="|")
        print("")

def print_cube_grid(cube_grid, include_coords = False):
    """
    Prints a pipe-separated table of integers representing a 3D grid as follows:
    0: air, 1: board, 2: water
    The 3D array must be a perfect cuboid / orthotope, as there is no error
    handling for extraneous array elements. 

    Parameters
    ----------
    topo_grid : 2D arr/list of lists
        A 2d Python array of integers, square or rectangular
    include_coords : bool, optional, default False
        Add 3D coordinates to each position in addition to the material
    
    Example Print Output
    --------------------
    Length 3, Width 3, Height 3
    |1|1|0| |0|0|0| |1|0|0| 
    |1|1|1| |0|0|0| |0|0|0| 
    |1|1|1| |0|0|0| |1|1|0|     
    
    """           
    length = len(cube_grid) 
    width = len(cube_grid[0])
    height = len(cube_grid[0][0])
    
    # Detect max digit length for clean right justification of table
    len_digits = len(str(length))-1
    wid_digits = len(str(width))-1
    ht_digits = len(str(height))-1
    
    print(f"Length {length}, Width {width}, Height {height}")
    for y in range(width):
        for x in range(length):
            print("", end="|")
            for z in range(height):
                if include_coords:
                    print("-".join([str(x).rjust(len_digits),
                        str(y).rjust(wid_digits),
                        str(z).rjust(ht_digits)]), end=":")
                print(f"{cube_grid[x][y][z].content}", end='|')
            print("", end=" ")
        print("")

def simulate_flood(cube_matrix):
    """
    The primary function that simulates flood physics upon the 3D matrix of
    TopoCubes passed. 

    Parameters
    ----------
    cube_matrix : 3D arr / list of lists of lists of TopoCube objects
        A 3D Python array of TopoCode objects generated in MakeCartesianGrid
    
    Returns
    -------
    cube_matrix : 3D arr / list of lists of lists of TopoCube objects
        A fullly extruded 3d Python array of TopoCube objects which hold 
        information about the content of each cube (air, board, or water)
  
    """
        
    # Establish the 3D parameters of the simulation based on matrix dimensions
    length = len(cube_matrix)
    width = len(cube_matrix[0])
    height = len(cube_matrix[0][0])    
    
    # Flood the topography one level at a time, beginning at bottom
    for flood_level in range(height):
        # Flood each square individually on this level with pathfinding
        for y in range(width):
            for x in range(length):
                
                # Store current cube as a shorter variable
                current_cube = cube_matrix[x][y][flood_level]
                cube_below = cube_matrix[x][y][flood_level-1]
                
                # Must be air to bother with recursive function 
                if current_cube.content == CONTENT_BOARD:
                    continue
                # Detect if there is air below. If not, then drain the square
                elif flood_level>0 and cube_below == CONTENT_AIR:
                    current_cube.content = CONTENT_AIR
                    continue
                # If we already detected that the square drains, drain & ignore
                elif current_cube.drains_out:
                    current_cube.content = CONTENT_AIR
                # Check if it's the edge of the board, if so, drain & ignore
                elif (0 in (x,y) or x == length-1 or y == width-1):
                    current_cube.drains_out = True
                
                elif current_cube.content == CONTENT_AIR:    

                    def drain():
                        """
                        The nested pathfinding function that crawls through the 
                        2D slice of the 3D grid at the current flood level to 
                        check for containment or drainage at each current 
                        position. It uses the current x, y, and flood_level 
                        values as the position.
                    
                        Returns
                        -------
                        True/False : bool
                            If the function detected that the current cube 
                            drains out, it returns True. If water pools at the 
                            cube, it returns False 
                        """
                        
                        # Keep track of unique touches during the pathfinding
                        touched = set([x,y])
                        # List of discovered coordinates that must be resolved 
                        pathfinding = [(x,y)]
                        
                        # Continue pathfinding until all paths exhausted
                        while pathfinding:
                            tx,ty = pathfinding.pop(0) # Continue pathfinding
                            # Track which squares have already been resolved
                            touched.add((tx,ty)) 
                            # Branch out from current path in 4 NESW directions
                            paths = [(0,-1),(1,0),(0,+1),(-1,0)]
                            for (i,j) in paths:
                                px, py = tx+i, ty+j
                                
                                # Store current path cube as a shorter variable
                                current_cube = cube_matrix[px][py][flood_level]
                                if (px,py) in touched:
                                    continue
                                # If we already detected drainage, then drain 
                                if current_cube.drains_out:
                                    return True
                                # Detect out-of-bounds pathfinding 
                                if not (0 <= px <= length-1) and \
                                    (0 <= py <= width-1):
                                    return True
                                # If path ran into water, then this also floods
                                if current_cube.content == CONTENT_WATER:
                                    return False
                                # Ignore watertight boards during pathfinding                                    
                                if current_cube.content == CONTENT_BOARD:
                                    continue
                                # If path hit edge of board, it always drains
                                if 0 in (px,py) or length-1 in (px,py):
                                    return True     
                                # If air, mark for more pathfinding and continue  
                                if current_cube.content == CONTENT_AIR:
                                    touched.add((px,py))
                                    pathfinding.append((px,py))
                        return False
                    drained = drain() # Execute the drain function for each x,y
                    # The function returns True for drains, False for pools
                    if drained: 
                        current_cube.drains_out = True 
                    else:
                        current_cube.content = CONTENT_WATER                    
    return cube_matrix # The final 3d array of TopoCubes which includes water
    
def flood_statistics(cube_matrix, request=None): 
    """
    This function produces two simple statistics of the fully flooded 3d cube 
    matrix produced by the simulate_flood() function. 

    Parameters
    ----------
    cube_matrix : 3D arr / list of lists of lists of TopoCube objects
        A 3D Python array of TopoCode objects that have been flooded with
        simulate_flood()
    
    Returns
    -------
    total_flooding (selectable) : int 
        Number of cubes in the 3D grid that retained water
    max_water_level (selectable) : int
        Highest level of water that remained after flooding the 3D grid
  
    """  
    
    total_flooding, max_water_level = 0, 0
    
    # Crawl through entire 3D matrix, count flooded cells and track max level
    for x in cube_matrix:
        for y in x:
            for z_index, z in enumerate(y):
                if z.content == CONTENT_WATER:
                    total_flooding +=1
                    max_water_level = max(z_index+1, max_water_level)
    
    # By default, function returns both stats, but either may be selected
    if request == 'total':
        return total_flooding
    elif request == 'maximum level':
        return max_water_level
    else:
        return (total_flooding, max_water_level)

def full_simulation(topo_grid=None, length=args.grid_length, 
    width=args.grid_width, max_height=args.max_height):
    """
    This function wraps all of the function and class calls required for flood 
    simulation into one function. This function is automatically called when 
    the script is invoked. It passes all arguments into the prepare_grid()
    function whether customized or defaulted to None, where they are then 
    handled appropriately. 

    Parameters
    ----------
    topo_grid : 2D arr / list of lists, optional
        A 2d Python array, square or rectangular
    length : int, optional, defaults to DEFAULT_LENGTH
        Desired length of a randomized 2D grid
    width : int, optional, defaults to DEFAULT_WIDTH
        Desired width of a randomized 2D grid, 
    max_height : int, optional, defaults to DEFAULT_MAX_HEIGHT
       Maximum values (height) of a randomized 2D grid

    Returns
    -------
    total_flooding : int, from flood_statistics() 
        Number of cubes in the 3D grid that retained water
    max_water_level : int, from flood_statistics()
        Highest level of water that remained after flooding the 3D grid
    """  
    
    # Send grid (random or custom) through prepare_grid() to groom & normalize
    groomed_grid, max_height = prepare_grid(topo_grid, length, width, 
        max_height)
    # Produce a 3D grid of TopoCubes that tracks contents of each cube
    cube_grid = MakeCartesianGrid(groomed_grid, max_height)
    # Now run the resulting 3d grid of cubes throught the flood simulator
    result = simulate_flood(cube_grid.cubes)
    
    # Print the final resulting grid with contents of each 3d position
    print_cube_grid(result)
    
    # Get and print the simple flood statistics of the 3D cube grid
    total_flooding, max_water_level = flood_statistics(result)
    print(f"Total flooding is {total_flooding} cubes.")
    print(f"Max water level is {max_water_level}.")
    return (total_flooding, max_water_level)

"""
This area automatically triggers the entire full_simulation from the command 
line, and accepts command line arguments as defined at the top of the script. 

To use the topographyfloodsim file like this, you may either pass your 
chessboard or grid in the conditional below, or you may request a random 
topography grid by executing this python file with all 3 arguments 
(-l, -w, and --mh) as documented above, like this example: 

python topographyfloodsim -l 8 -w 8 --mh 10

If you choose to randomize, but omit one or more of the three arguments, the 
script will use the defaults for each dimension as defined at the top of the
script. 

"""

if __name__ == '__main__':
    
    # Check if any of 3 arguments were passed, otherwise pass this grid
    if not any([args.grid_length, args.grid_width, args.max_height]):
        chessboard = [  [0,8,8,7,7,4,4,4],
                        [8,0,0,0,0,0,0,3],
                        [8,0,0,0,0,0,0,3],
                        [4,0,0,0,0,0,0,4],
                        [4,0,0,0,0,0,0,3],
                        [4,0,0,0,0,0,0,4],
                        [4,0,0,0,0,0,0,3],
                        [4,6,6,6,4,4,4,4],
        ]
    else: 
        chessboard = None
    
    # Execute entire simulation w/ printed results & return variables if needed 
    full_simulation(chessboard)

    